var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import React from 'react';
import { Dimensions, StyleSheet, TouchableOpacity, } from 'react-native';
import { Interaction, } from '../../theme';
import { Text, } from '../text/text.component';
import { Popover, } from '../popover/popover.component';
import { NativeDateService } from '../calendar/service/nativeDate.service';
const FULL_DATE_FORMAT_STRING = 'DD/MM/YYYY';
export class BaseDatepickerComponent extends React.Component {
    constructor() {
        super(...arguments);
        this.state = {
            visible: false,
        };
        this.getComponentStyles = (style) => {
            const { popoverMarginHorizontal, textFontSize, textLineHeight, textFontWeight, textFontFamily, textColor, iconWidth, iconHeight, iconTintColor } = style, containerStyles = __rest(style, ["popoverMarginHorizontal", "textFontSize", "textLineHeight", "textFontWeight", "textFontFamily", "textColor", "iconWidth", "iconHeight", "iconTintColor"]);
            return {
                container: containerStyles,
                icon: {
                    width: iconWidth,
                    height: iconHeight,
                    tintColor: iconTintColor,
                },
                text: {
                    fontSize: textFontSize,
                    lineHeight: textLineHeight,
                    fontWeight: textFontWeight,
                    color: textColor,
                    fontFamily: textFontFamily,
                },
                popover: {
                    indent: popoverMarginHorizontal,
                },
            };
        };
        this.onPressIn = (event) => {
            this.props.dispatch([Interaction.ACTIVE]);
            if (this.props.onPressIn) {
                this.props.onPressIn(event);
            }
        };
        this.onPressOut = (event) => {
            this.props.dispatch([]);
            if (this.props.onPressOut) {
                this.props.onPressOut(event);
            }
        };
        this.toggleVisible = () => {
            const visible = !this.state.visible;
            this.setState({ visible }, this.dispatchActive);
        };
        this.dispatchActive = () => {
            if (this.state.visible) {
                this.props.dispatch([Interaction.ACTIVE]);
            }
            else {
                this.props.dispatch([]);
            }
        };
        this.renderIconElement = (style) => {
            const iconElement = this.props.icon(style);
            return React.cloneElement(iconElement, {
                style: [style, iconElement.props.style],
            });
        };
        this.renderTextElement = (style) => {
            return (<Text style={style}>
        {this.getComponentTitle()}
      </Text>);
        };
        this.renderControlChildren = (style) => {
            const { icon } = this.props;
            return [
                this.renderTextElement(style.text),
                icon && this.renderIconElement(style.icon),
            ];
        };
        this.renderControl = () => {
            const { themedStyle, disabled, style } = this.props;
            const componentStyle = this.getComponentStyles(themedStyle);
            const [textElement, iconElement] = this.renderControlChildren(componentStyle);
            return (<TouchableOpacity activeOpacity={1.0} disabled={disabled} style={[componentStyle.container, styles.container, style]} onPress={this.toggleVisible} onPressIn={this.onPressIn} onPressOut={this.onPressOut}>
        {textElement}
        {iconElement}
      </TouchableOpacity>);
        };
    }
    formatDateToString(date) {
        return this.props.dateService.format(date, FULL_DATE_FORMAT_STRING);
    }
    render() {
        const { popover } = this.getComponentStyles(this.props.themedStyle);
        const popoverStyle = {
            width: Dimensions.get('window').width - popover.indent,
            maxWidth: Dimensions.get('window').width - popover.indent,
        };
        return (<Popover style={popoverStyle} visible={this.state.visible} content={this.renderCalendar()} onBackdropPress={this.toggleVisible}>
        {this.renderControl()}
      </Popover>);
    }
}
BaseDatepickerComponent.defaultProps = {
    dateService: new NativeDateService(),
    placeholder: 'dd/mm/yyyy',
};
const styles = StyleSheet.create({
    container: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'space-between',
    },
});
//# sourceMappingURL=baseDatepicker.component.js.map